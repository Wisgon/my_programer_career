1. Map() 函数的坑：
   python3 的map函数，不会直接返回列表，也就是说还没有对所有对象应用到某个方法进行运算，只有当用list()函数作用时才进行运算，如： 

   ```python
   def f(a):
     return a+1      
   lst1  = [3,4,5]               
   lst2 = map(f, lst1)  
   ```

   此时的lst2里的元素并不是lst1对应的元素+1之后的，而是一个map对象，当用lst2 = list(lst2)作用时，lst2才是想要的东西;

2. Anaconda 安装指定编号的包：
   `conda install  caffe2=0.8.dev=py27h729c78d_0`
   就ok了;

3. Python中没有null，只有None，判断一个值是否为空最好不要直接`if not var: `,而是要`if var is None:`  反过来是：`if var is not None:`；

4. 通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的`[]`改成`()`，就创建了一个generator，可以通过`next()`函数获得generator的下一个返回值：

   ```python
   g = (x*x for x in range(10))
   next(g)  # 0
   next(g)  # 1
   for i in g:
     print(i)
   #4, 9, 16, 25, 36, 49, 64, 81  注意，不会从0开始，因为前两个已经用掉了，for循环开始的位置是第三个！
   ```

   <br><br> 

5. 定义generator的另一种方法。如果一个函数定义中包含`yield`关键字，那么这个函数就不再是一个普通函数，而是一个generator：

   ```python
   def fib(max):
       n, a, b = 0, 0, 1
       while n < max:
           yield b
           a, b = b, a + b
           n = n + 1
       return 'done'
   g = fib(6)  # 此时g是一个generator
   ```

   这里，最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到`return`语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用`next()`的时候执行，遇到`yield`语句返回，再次执行时从上次返回的`yield`语句处继续执行。<br><br> 

6. 可以使用`isinstance()`判断一个对象是否是`Iterable`对象：

   ```python
   from collections import Iterable
   isinstance([], Iterable)  # True
   ```

   <br><br> 

7. 可以被`next()`函数调用并不断返回下一个值的对象称为迭代器：`Iterator`,是iterable对象不代表就是迭代器，如list就不是。 把`list`、`dict`、`str`等`Iterable`变成`Iterator`可以使用`iter()`函数：`isinstance(iter([]), Iterator)` 返回True；`Iterator`的计算是惰性的，只有在需要返回下一个数据时它才会计算。<br><br>

8. `a='3', b='r',` `print('%s and %s():' % (a, b))`  打印"3 and r"；<br><br> 

9. 

