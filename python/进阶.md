1. Map() 函数的坑：
   python3 的map函数，不会直接返回列表，也就是说还没有对所有对象应用到某个方法进行运算，只有当用list()函数作用时才进行运算，如： 

   ```python
   def f(a):
     return a+1      
   lst1  = [3,4,5]               
   lst2 = map(f, lst1)  
   ```

   此时的lst2里的元素并不是lst1对应的元素+1之后的，而是一个map对象，当用lst2 = list(lst2)作用时，lst2才是想要的东西;

2. Anaconda 安装指定编号的包：
   `conda install  caffe2=0.8.dev=py27h729c78d_0`
   就ok了;

3. Python中没有null，只有None，判断一个值是否为空最好不要直接`if not var: `,而是要`if var is None:`  反过来是：`if var is not None:`；

4. 通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的`[]`改成`()`，就创建了一个generator，可以通过`next()`函数获得generator的下一个返回值：

   ```python
   g = (x*x for x in range(10))
   next(g)  # 0
   next(g)  # 1
   for i in g:
     print(i)
   #4, 9, 16, 25, 36, 49, 64, 81  注意，不会从0开始，因为前两个已经用掉了，for循环开始的位置是第三个！
   ```

   <br><br> 

5. 定义generator的另一种方法。如果一个函数定义中包含`yield`关键字，那么这个函数就不再是一个普通函数，而是一个generator：

   ```python
   def fib(max):
       n, a, b = 0, 0, 1
       while n < max:
           yield b
           a, b = b, a + b
           n = n + 1
       return 'done'
   g = fib(6)  # 此时g是一个generator
   ```

   这里，最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到`return`语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用`next()`的时候执行，遇到`yield`语句返回，再次执行时从上次返回的`yield`语句处继续执行。<br><br> 

6. 可以使用`isinstance()`判断一个对象是否是`Iterable`对象：

   ```python
   from collections import Iterable
   isinstance([], Iterable)  # True
   ```

   <br><br> 

7. 可以被`next()`函数调用并不断返回下一个值的对象称为迭代器：`Iterator`,是iterable对象不代表就是迭代器，如list就不是。 把`list`、`dict`、`str`等`Iterable`变成`Iterator`可以使用`iter()`函数：`isinstance(iter([]), Iterator)` 返回True；`Iterator`的计算是惰性的，只有在需要返回下一个数据时它才会计算。<br><br>

8. `a='3', b='r',` `print('%s and %s():' % (a, b))`  打印"3 and r"；<br><br> 

9. `global`在这的意思是什么？`global`变量意味着我们可以在函数以外的区域都能访问这个变量。让我们通过一个例子来证明它：

   ```python
   # 首先，是没有使用global变量
   def add(value1, value2):
       result = value1 + value2
   
   add(2, 4)
   print(result)
   
   # Oh 糟了，我们遇到异常了。为什么会这样？
   # python解释器报错说没有一个叫result的变量。
   # 这是因为result变量只能在创建它的函数内部才允许访问，除非它是全局的(global)。
   Traceback (most recent call last):
     File "", line 1, in
       result
   NameError: name 'result' is not defined
   
   # 现在我们运行相同的代码，不过是在将result变量设为global之后
   def add(value1, value2):
       global result
       result = value1 + value2
   
   add(2, 4)
   print(result) #6
   ```

   <br><br> 

10. 每当你将一个变量赋值为另一个可变类型的变量时，对这个数据的任意改动会同时反映到这两个变量上去。新变量只不过是老变量的一个别名而已。这个情况只是针对可变数据类型。下面的函数和可变数据类型让你一下就明白了：

   ```python
   def add_to(num, target=[]):
       target.append(num)
       return target
   
   add_to(1)
   # Output: [1]
   
   add_to(2)
   # Output: [1, 2]
   
   add_to(3)
   # Output: [1, 2, 3]
   ```

   在Python中当函数被定义时，默认参数只会运算一次，而不是每次被调用时都会重新运算。你应该永远不要定义可变类型的默认参数，除非你知道你正在做什么。<br><br> 

11. **locals()** 函数会以字典类型返回当前位置的全部局部变量，可用在避免类初始化时大量重复的赋值语句：

    ```python
    class A(object):
            def __init__(self, a, b, c, d, e, f):
                self.__dict__.update({k: v for k, v in locals().items() if k != 'self'})
    ```

    <br><br> 

12. `for`循环还有一个`else`从句，我们大多数人并不熟悉。这个`else`从句会在循环正常结束时执行。这意味着，循环没有遇到任何`break`:

    ```python
    for item in container:
        if search_something(item):
            # Found it!
            process(item)
            break
    else:
        # Didn't find anything..
        not_found_in_container()
    ```

    <br><br> 

13. f-Strings：一种改进Python格式字符串的新方法：

    ```python
    name = "Eric"
    age = 74
    f"Hello, {name}. You are {age}."
    ```

    <br><br> 

14. 一个序列就是实现了`__len__`、`__getitem__`的类，如：

    ```python
    class TestSeq:
        def __init__(self):
            self._a = [3,4,5]
        def __len__(self):
            return len(self._a)
        def __getitem__(self, p):
            return self._a[p]
            
    t1 = TestCol()
    from random import choice
    choice(t1)  # 随机从t1的_a列表里取出一个元素
    ```

    <br><br> 

15. `*`符号的作用之一是折包：

    ```python
    def f(a, b):
        return a+b
    par = (3, 4)
    f(*par)  # 相当于拆包成f(3, 4)
    ```

    <br><br> 

16. `*`符号的作用之二是获得剩下的参数，如在函数定义中的`*args`：

    ```python
    def f(a, b,c, *args):
        print(args[0], args[1])
    a, b, *rest = range(5)
    print(rest)  # rest是列表[2,3,4]
    l1 = [a, *rest, b]
    print(l1)  # l1是列表[0, 2, 3, 4, 1]
    ```

    <br><br> 

17. collections的nametuple模块产生一个具名元组：

    ```python
    from collections import namedtuple
    City = namedtuple('C1', "name, country, coor")
    toyko = City("Tokyo", "JAP", (35.666, 139.555))
    print(toyko)  # C1(name='Tokyo', country='JAP', coor=(35.666, 139.555))
    ```

    <br><br> 

18. `*`符号的作用之三是复制列表：

    ```python
    s1 = [3,4]
    s1*3  # [3,4,3,4,3,4]
    ```

    但是要注意：

    ```python
    s3 = [[3,4]]
    s4 = s3*3  # s4 为[[3, 4], [3, 4], [3, 4]]
    s4[0][1] = 5  # 此时的s4为 [[3, 5], [3, 5], [3, 5]]
    ```

    `*`号在复制列表时，如果元素是列表或其他可变对象，则只复制引用，有时这并不是我们想要的结果！<br><br>

19. 三个文件 a.py，b.py，c.py：
    a.py:

    ```python
    x = 1
    ```

    b.py:

    ```python
    import a
    a.x = 2
    ```

    c.py:

    ```python
    from a import x
    x = 2
    ```

    只有b.py才真正修改了a中的x，c.py这样import的方式，相当于在c.py下执行`x=2`，x变成了在自己的命名空间下的变量了！<br><br>

20. Linux 下python检查设备信息：

    ```python
    import os
    sudoPassword = 'rzh930209'
    # 获取CPU ID
    command1 = 'dmidecode -t 4 | grep ID'
    res1 = os.popen('echo %s|sudo -S %s' % (sudoPassword, command)).read()
    # 获取主板序列号
    command2 = 'dmidecode -t 2 | grep Serial'
    res2 = os.popen('echo %s|sudo -S %s' % (sudoPassword, command)).read()
    # 获取MAC地址
    command3 = 'lshw -c network | grep serial | head -n 1'
    res3 = os.popen('echo %s|sudo -S %s' % (sudoPassword, command)).read()
    ```

    <br><br>

21. GB2312原始字符串转字符的方法：

    ```python
    name_str = "193&250&184&231&"  # gb2312的原始字节数字
    name = []
    a = name_str.split("&")[:-1]
    # print(str(hex(int(a[0]))).replace('0', '\\'))
    for hs in a:
        #name += str(hex(int(hs)))
        name.append(int(hs))
    s = "龙哥"
    c = s.encode("gb2312")
    print(c)
    print(name)
    res = bytes(name)
    print(res.decode('gb2312'))  # res和c是一样的了
    ```

    <br><br>

22.  重新加载模块：

```python

import importlib, sys
importlib.reload(sys.modules['a'])
# a为自己自定义的模块名，可以用在sys.modules.keys()里面查找


```

<br><br>

23. win10设置时间：

    ```python
    import win32api
    
    
    time_tuple = ( 2019, # Year
                      11, # Month
                      25, # Day
                      0, # Hour
                     38, # Minute
                      0, # Second
                      0, # Millisecond
                  )
    
    def win_set_time(time_tuple):
        dayOfWeek = datetime.datetime(*time_tuple).isocalendar()[2]
        t = time_tuple[:2] + (dayOfWeek,) + time_tuple[2:]
        win32api.SetSystemTime(*t)
    
    win_set_time(time_tuple)
    ```

    需要安装win32api，下载地址：<https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/><br><br>

24. multiprocessing模块，父子进程的子进程在父子进程结束时还是会在运行状态的，父子进程的is_alive()仍然为True，只有子子进程也结束时，才算真正的结束;<br><br>

25. eval()只能用于执行表达式，而要定义函数，则需要exec：

    ```python
    eval(f"""
    @socket.on('alarm_win{str(i)}', namespace=name_space1)
    def send_msg_handler(message):
        send_message(name_space1, "alarm_win{str(i)}", message)
    """)  # 报错
    
    exec(f"""
    @socket.on('alarm_win{str(i)}', namespace=name_space1)
    def send_msg_handler(message):
        send_message(name_space1, "alarm_win{str(i)}", message)
    """)  # 正确
    ```

    <br><br>

26. 在部署智慧磐石项目，遇到pymysql的报错：`TypeError: string argument without an encoding`，这时直接修改pymysql的相应的报错的位置的源码，bytes(s)改为bytes(s.encode('utf-8'))即可；<br><br>

27. 
