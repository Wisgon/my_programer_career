1. let 关键字会定义变量，如果没有加mut，则是不可变变量，其实不可变变量并不是绝对不可变，如：
	```rust
	let x = 5;
	x = 6;  //这里就会报错了，因为x是不可变变量
	let y = 7;
	let y = y + 1;
	let y = 2;
	println!("y is {}", y); //这里不会报错了，因为let相当于又重新定义了一遍这个变量
	```
	
	<br><br> 
	
2. rust是一门基于表达式的语言，如果没有分号，则默认是表达式：

   ```rust
   fn main() {
   	let x = 5;
   	let y = {
   		let x = 3;
   		x + 1
   	};
   	
   	println!("The value of y is: {}", y);
   }
   ```

   注意结尾没有分号那一行x+1，是一个表达式，有返回值，是4，所以y的值是4，如果结尾是分号，则是一个语句，语句不会有返回值；<br><br> 

3. 函数的返回值等同于函数体最后的表达式，如：

   ```rust
   fn five -> i32 {
     5
   }
   fn main() {
     let x = five();
   }
   ```

   这时的x就是5，也可以用return显示地指定返回值，并退出；<br><br> 

4. **条件表达式只能接受bool值**，其它值都会报错；<br><br> 

5. if和else的返回值必须类型一致，如：

   ```rust
   let x = if number < 3 {
   	3
   } else {
     "3"
   }
   ```

   会报错，因为返回类型不一样；<br><br> 
   
6. 对于内存回收，rust采用的策略是，内存在拥有它的变量离开作用域后就被自动释放；

7. `let s1 = String::from("hello"); let s2 = s1;`  这个操作会使变量s1失效，rust不会显式地复制一个变量，这就解决了二次释放内存的问题；<br><br> 

8. rust中，变量传递给函数，跟上一点效果一样，也会使这个变量失效，在函数后面无法再使用，因为在函数结束后变量就被释放了，所以在编写rust代码的时候，**要时刻谨记着哪些变量是要重复用的，哪些是一次性的**；<br><br> 

9. 用指针传入函数相当于传入引用，而不会使原变量失效，也就是所有权还在原变量身上，也可以叫“借用”，而在函数中，是不允许修改这个借用值的，除非在调用时用的是 call_func(your_var: $mut String)，此时your_var是String类型，而且是可变的，叫可变引用，**print!("{}", var1)，相当于调用了var1的不可变引用**；<br><br> 

10. ### 重点：

  **同一个作用域只能有一个可变引用**，也就是下面这样会报错，但是可以有多个不可变引用，但又不可以同时有可变与不可变引用，但是当不可变引用结束，又可以使用可变引用了，前提是可变引用后面不再有不可变引用：

  ```rust
  let mut s1 = String::from("Hi");
  let x1 = &s1;
  let x2 = &s1; //没问题
  let mut s2 = String::from("hello");
  let r1 = &mut s2;
  let r2 = &mut s2;  //报错
  let mut s3 = String::from("ni hao");
  let y1 = &s3;
  let y2 = &mut s3; //不会报错
  println!("{}", y1); //报错，试图引用一个有可能被改变的不可变变量；
  
  let mut s4 = String::from("ko mu ji wo");
  let k1 = &s4;
  let k2 = &s4;
  println!("{} and {}", k1, k2);
  let k3 = &mut s4;
  //后面将不会报错,只要此位置后，k1, k2不再使用
  println!("{}", k3)
  ```

  <br><br> 

11. rust中，大括号{}相当于圈定一个作用域，可以看作是一个表达式，**宏调用也是一个表达式**，如：

    ```rust
    let a = println!("{}",some_var);
    println!("{:?}",a); //因为a不是普通变量了，所以用{:?}格式化，打印出"()"，是个空元组
    ```

    <br><br> 

12. 字符串字面值的类型是"&str"，是一个指向二进制程序特定位置的slice，**它没有那个slice的所有权**，所以它是不可变的；<br><br> 

13. 